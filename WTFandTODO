_________________________________WTF?!____________________________________
The main goal of this project is creation of embeddable version of DosBox,
which may relatively easily run on something really low-cost. Like STM32
microcontrollers.
So the first thing needed to be done is truncation of source code tree.
The vanilla dosbox compiled on $(see gcc.ver) weights 10.8 MB*
Current version (on the same machine with the same toolchain) weights 9.0 MB*
and still counting down.
This is a fun weekend project, so don't expect anything really usable :)
But if you want to run your beloved DOOM** or even a full Win95 install on a 
homebrew USB-stick-sized cardboard PC (which will cost you around $15) -- feel
free to contribute and share the fun!
*-----
	Unstripped versions. DosCard XShell have SDL2 linked statically, so the 
	real size is much lower (~4 MB less).
**----
	Yes, I know about over 9000 implementations of DOOM or Quake engines, but
	it's not what I want to see. Porting a full DOS makes it possible to run
	heavy old programs (not only a games) without a pain of porting.


_________________________________TODO________________________________________


1. Truncate the code tree to exclude everything unneeded
	Scalers: this thing is really useful but render_scalers.o only weights > 3MB
	and so that's a real problem! In our setup we will scale image down to fit
	the small cheap 320x240 TFT display instead of enhancing quality to show on
	full-wall-sized plasma TV.
	Debug: debugger usability in embedded systems is a hard question. Moreover,
	internal DosBox debugger makes it not possible to run some DPMI apps.
	For example, Win95 crashes after showing a desktop. The solution for now
	is to leave the code on place, but undef all C_DEBUG defines.
	Hardware: I don't need GUS, EGA, CGA and many other things. The only things
	I need is SVGA (s3) and SoundBlaster (which uses OPL, btw).
->ALMOST DONE!

2. Decide what to do with SDL.
	Pros: SDL has well-maintained code and it's really simple to write your
	own hardware driver and put it to the tree.
	Cons: SDL has weight. There's not so much things to do with this fact.
	SDL needs threads. I can't see any way to make SDL audio works without
	threading enabled. Next, DosBox uses pretty old SDL 1.2, with all of this 
	'surfaces' and other old stuff. So it would be useless to port OLD SDL to a 
	custom platform because a lifeline of 1.2 is near it's end.
	Conclusion: Wipe out SDL code and make my own wrapper to easily move between
	debugging on a Core-i7 based gametop PC to running on a STM32 cardboard :)
	Moreover, the new SDL 2.0 brings the new capability of running scaling code
	directly on your nVidia TITAN GPU !!! So the render_scalers can be wiped out
	next to old SDL, heehaw!
-> DONE!

	
3. Refactor code. It's highly improbable that we will want to merge something
from upstream DosBox due to fact of everything we want is already working.
I had decided that will be a lib, libdosbox. There will be two versions of this:
(a) x86 GNU/Linux static or/and shared lib; and (b) embeddable library to just
include in your hobby microcontroller project. Nice, isn't it?
Notes: Coding style is not the best I've ever seen. To be honest, it's worstest
style I've ever seen. Classes scattering around without any real purpose. Huge
amount of globals everywhere. Almost none of the core classes can be instantiated
more than once. Really obfuscated function calls, amount of function pointers 
magic in trivial places, etc, etc.
Update: dynamic library created by wrapping all (really unrefactorable) old dosbox
code into LLVM bitcode file. Now we use LLVM to start separated instances of box
and that's working so far (without the ability of running W95, though).
-> DONE!


4. Select a chip to port this thing into and draw the schematics
5. Write the ld script for a chip selected (arm/chip/load.ld)
6. Write our own crt0 replace for this chip (arm/chip/start.S)

7. Made something with CDROM_ImageFile AudioFile - Using SDL_sound is just unreal.

8. Cut and replace all filesystem IO code with XShell Callbacks - in real chip
we obviously won't have a "normal" disk filesystem.
List of functions remains to be (re)moved (not FIO only):
stat()/fstat() -> OK
time()/localtime() -> OK
opendir()/readdir() -> OK
-> I THINK IT'S DONE


9. Move all of the libdosbox code into it's own namespace.
-> DONE!

10. Check and clean up all the files in INCLUDE directory!
-> DONE!

11. Do something with VM' internal clocks. One of the hardest bugs is the clocking
errors. For example, W95 will not load properly in hi-res mode without -O2 flag.
Which means, the richness of functionality of guest OS lies on host system 
performance. That's bad!
UPD: I think that isn't an issue. The problem relevant to timing, but in some other
way. Deep investigation needed!
HINT: heavy use of GCC attributes in original code can make GCC crazy.
UPD: different GCC versions generates very different code. Program won't work with
gcc 4.6 or 4.7. Moreover, linkage order have it's own magic on the code stability.
UPD: -fPIC changes nothing
->STALLED

12. Types unification. Use <inttypes> instead of all of this Bit<xx>[s/u] forms.
-> DONE! (by typedef kludge)

13. Deal with manual exceptions and its catches. This might unveil big problems while
porting on possible target arch.

14. Get rid of static qualifiers. Make sure there's no static methods or members.
->STALLED

15. Run a set of statical analysis processes to seek and eliminate violations,
unused code, creepy pointer arithmetic and so on.
Note: Understand 3.1 had found >19000 violations on a smallest ruleset. More complex
rulesets may unveil much more violations and potential problems. The number was
lowered to 3973 after unchecking some unimportant checks. About 3-5% of this number
is really potential problems.
->STALLED

16. Get rid of HOST_xxBIT define. Use some standard type, which will have properly
width on all platforms.

17. Near the end of porting we should finally check all of inclusions in all our
files by find'ing, grep'ing and sort'ing.

18. Destroy MSG system to move all this string constants from data to code area and
save some amount of RAM. Moreover, DOS in any language different from English is just
a stupid crazy thing (lobotomized vegetables may prefer it). May be I don't speak
Englush very well (and it's true), but I can't use any OS with my native language
interface. Sometimes I was forced to do such things, but now I switched to Gentoo, so
I'm a boss :)
Note: while moving to a "new" system (just defines, nothing more) some of old "macro"
strings was detected as broken e.g. "PROGAM_MOUNT_ILL_TYPE" or "MSCDEX_ERROR_PATH"
some of them contains typos, some just missing. The system wasn't be able to catch
such errors.
-> DONE!

